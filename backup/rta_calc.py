# -*- coding: utf-8 -*-
"""RTA_Calc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15yfeFkm0DxsRVlYa77fKWVxjVnmiOWmm
"""

!python -m pip install pymongo[srv] --user
!python -m pip install pymongo==3.9.0 --user

import pandas as pd
import json as json
import datetime
from pymongo import MongoClient
from bson import ObjectId
import numpy as np
import time
import math
from sklearn.svm import SVR
import matplotlib.pyplot as plt
from scipy import stats
from collections import defaultdict
from sklearn.ensemble import RandomForestRegressor

def obj_dict(obj):
    return obj.__dict__

def calc_error(predicted,actual):
  error=0
  for i in range(0,len(actual)):
    error=error+((actual[i]-predicted[i])*(actual[i]-predicted[i]))
  error=error/len(actual)
  return math.sqrt(error)

def removeOutliers(frequency,threshold):
  modified_freq=[]
  modified_quantity=[]

  for freq,arr in frequency.items():
    if(len(arr)==1):
      modified_freq.append(freq)
      modified_quantity.append(arr[0])
    else:
      z=stats.zscore(arr)
      for idx in range(0,len(z)):
        if(np.isnan(z[idx])==True):
          modified_freq.append(freq)
          modified_quantity.append(arr[idx])
        elif(abs(z[idx])<threshold):
          modified_freq.append(freq)
          modified_quantity.append(arr[idx])
  return modified_freq,modified_quantity

    
def get_dates_quantity(dates,quantity,remove_outliers=0,outliers_threshold=0): 
  dates_arr=[]
  frequency_distribution={} 
  for i in range(1,len(dates)):
    frequency=(dates[i]-dates[i-1]).astype('int64')
    dates_arr.append(frequency)
    frequency_distribution[frequency]=[]

  quantity=quantity[1:]
  #plt.plot(dates_arr,quantity,'o',color='red')
  if(remove_outliers==1):
    for idx in range(0,len(dates_arr)):
      frequency_distribution[dates_arr[idx]].append(quantity[idx])
    # print("FREQ")
    # print(frequency_distribution)

    modified_dates,modified_quantity=removeOutliers(frequency_distribution,outliers_threshold)
    #plt.plot(modified_dates,modified_quantity,'o',color="yellow")
    #plt.show()
    modified_dates=np.array(modified_dates).astype('int64')
    modified_dates=np.reshape(modified_dates,(len(modified_dates),1))
    return modified_dates,modified_quantity
  else:
    dates_arr=np.array(dates_arr).astype('int64')
    dates_arr=np.reshape(dates_arr,(len(dates_arr),1))
    return (dates_arr,quantity)


def algo(dates,quantity,gap):
  dates = np.array(dates).astype('datetime64[D]')

  #preparing frequncy array(dates_arr)
  (dates_arr , quantity) = get_dates_quantity(dates,quantity,1,1.5)
  
  #INITIALISING THE MODEL
  #svr_poly=SVR(kernel='poly',C=1e3,degree=2,gamma="auto")-- CURRENTLY NOT USING POLY
  svr_rbf=SVR(kernel='rbf',C=1e3,gamma=0.1)
  random_forest = RandomForestRegressor(n_estimators=30,random_state=10)

  #FITTING THE MODEL
  #svr_poly.fit(dates_arr,quantity)-- CURRENTLY NOT USING POLY
  svr_rbf.fit(dates_arr,quantity)
  random_forest.fit(dates_arr,quantity);

  #READING THE CURRENT TIMESTAMP TO FIND THE GAP
  predict_dates = gap
  predict_dates = np.reshape(predict_dates,(1,1))
 
  #PREDICTING FROM THE FITTED MODEL
  if predict_dates > max(dates_arr):
    maximum = max(dates_arr)[0]
    k = 0
    max_quant = 0
    for i in dates_arr:
        if (i[0] == maximum):
            if (quantity[k] > max_quant):
                max_quant = quantity[k]
        k += 1
   
    return(round(max_quant))

  rbf= svr_rbf.predict(dates_arr)
  rf=random_forest.predict(dates_arr)#rf=Random Forest
  
  rounded_rbf=[]
  rounded_rf=[]

  for i in range(0,len(rbf)):
    rounded_rbf.append(round(rbf[i]))
    rounded_rf.append(round(rf[i]))
  error_rbf=calc_error(rounded_rbf,quantity)
  error_rf=calc_error(rounded_rf,quantity)
  print(error_rbf,error_rf)
  if(error_rbf<=error_rf):
    return svr_rbf.predict(predict_dates)[0]
  else:
    return random_forest.predict(predict_dates)[0]
  # plt.plot(dates_arr,quantity,'.',color='red')
  # plt.plot(dates_arr,poly,'.',color='blue')
  # plt.plot(dates_arr,rbf,'.',color='green')

  # plt.show()


def JsonPrediction(transaction,itemID,gap):
  item = transaction.find({"cust_id":25},{"Transaction.item_transactions.date":1, "Transaction.item_transactions.quantity":1,"Transaction.item_id":1,"_id":0}).sort("Transaction.item_transactions.date")
  # print(item)
  # output = []
  
  for x in item:
    for y in x["Transaction"]:
      
      dates = []
      quantity = []
      
      if(y['item_id']==itemID):
        item_trans = y['item_transactions']
        for z in item_trans:
          
          dates.append(z['date'])
          quantity.append(z['quantity'])
        
        # print(dates,quantity)
        ans = algo(dates,quantity,gap)       
        return ans


client = MongoClient('mongodb+srv://test:test@cluster0-nihvn.mongodb.net/test?retryWrites=true&w=majority')
db = client.get_database('shop_list')
transaction = db.transaction
rta = db.rta #Getting the rta table

# itemlist = db.itemlist

itemDetails = rta.find({'cust_id':25},{'item_details.avg':1 ,'item_details.last_date':1,'_id':0 , 'item_details.item_id':1 })#Mongo query

output = []
cnt=0
for item in itemDetails:
      for one_item in item['item_details']:
        avg = one_item['avg'] #Fetch the avg of an item for a particular user
        
        datetimeobj = datetime.datetime.now()
        
        cnt=cnt+1
        
        date = datetimeobj.strftime("%Y") + "-" +datetimeobj.strftime("%m") + "-" + datetimeobj.strftime("%d")
        
        last_date_of_purchase=one_item['last_date']
        
        
        t = (datetime.datetime.strptime(date,"%Y-%m-%d") - datetime.datetime.strptime(last_date_of_purchase,"%Y-%m-%d"))
        
        t = t.days
        avg=round(avg)
        if(avg !=0 and ((avg)-2)<=t and t<=(avg+3)):
            
            item_pred = {}
            itemid = one_item['item_id']
            ans = JsonPrediction(transaction=transaction,itemID=itemid,gap=t)
            
            
            dictionary = dict({'item_id' : itemid})

            # itemName = itemlist.find( dictionary, {'item_name':1 ,'item_id':1, '_id':0})
            
            item_pred['itemID'] = itemid
            # for name in itemName['item_name']:
            #   item_pred['itemName'] = name
            item_pred['Quantity'] = ans
            output.append(item_pred)
            print(item_pred)

        # # else:
        # #     print("DO NOT PREDICT for gap %d avg %f "%(t,avg))
ayush = [{'item_id':1 , 'item_name':'tea' , 'quantity':4} , {'item_id':2 , 'item_name':'apples' , 'quantity':2} , {'item_id':3 , 'item_name':'tomato' , 'quantity':5} ,
         {'item_id':4 , 'item_name':'cabbage' , 'quantity':2} , {'item_id':5 , 'item_name':'pen' , 'quantity':3}]
json_output_ayush = json.dumps(ayush)
return json_output

