# -*- coding: utf-8 -*-
"""Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V2xKGot09u73G7ED-NmVtpMyzm5B8Oz5
"""

import pandas as pd
import json as json
import datetime
from pymongo import MongoClient
from bson import ObjectId
import numpy as np
from sklearn.svm import SVR

def get_db():
  client = MongoClient('mongodb+srv://test:test@cluster0-nihvn.mongodb.net/test?retryWrites=true&w=majority')
  db = client.get_database('shop_list')
  transaction = db.transaction
  itemlist = db.itemlist
  rta = db.rta
  return (transaction , itemlist , rta)


def get_dates_quantity(dates,quantity): 
  dates_arr=[]
  for i in range(1,len(dates)):
    dates_arr.append(dates[i]-dates[i-1])

  dates_arr=np.array(dates_arr).astype('int64')
  dates_arr=np.reshape(dates_arr,(len(dates_arr),1))
 
  quantity=quantity[1:]
  return(dates_arr,quantity)

def algo(dates,quantity,last_date):
  dates = np.array(dates).astype('datetime64[D]')
 
  #preparing frequncy array(dates_arr)
  (dates_arr , quantity) = get_dates_quantity(dates,quantity) 

  #INITIALISING THE MODEL
  svr_poly=SVR(kernel='poly',C=1e3,degree=2,gamma="auto")
  svr_rbf=SVR(kernel='rbf',C=1e3,gamma=0.1)

  #FITTING THE MODEL
  svr_poly.fit(dates_arr,quantity)
  svr_rbf.fit(dates_arr,quantity)

  #READING THE CURRENT TIMESTAMP TO FIND THE GAP
  datetimeobj = datetime.datetime.now()
  date = datetimeobj.strftime("%Y") + "-" +datetimeobj.strftime("%m") + "-" + datetimeobj.strftime("%d")
  
  predict_dates = (datetime.datetime.strptime(date,"%Y-%m-%d")- datetime.datetime.strptime(str(dates[-1]) , "%Y-%m-%d")).days
  predict_dates = np.reshape(predict_dates,(1,1))
 
  #PREDICTING FROM THE FITTED MODEL
  if predict_dates > max(dates_arr):
        maximum = max(dates_arr)[0]
        k = 0
        max_quant = 0
        for i in dates_arr:
            if(i[0] == maximum ):
                if(quantity[k] > max_quant):
                    max_quant = quantity[k]
            k+=1
        return round(max_quant)
        
  elif predict_dates in dates_arr:
        y = svr_poly.predict(predict_dates.reshape(-1,1))[0]
        return round(y)
  else:
        y = svr_rbf.predict(predict_dates.reshape(-1,1))[0]
        return round(y)

def JsonPrediction(transaction , itemlist):
  item = transaction.find({"cust_id":25 , "Transaction.item_id" : 2808},{"Transaction.item_transactions.date":1, "Transaction.item_transactions.quantity":1,"Transaction.item_id":1,"_id":0}).sort("Transaction.item_transactions.date")
  
  
  output = []
  for x in item:
    trans=x["Transaction"]
    # RTA CONDITION CHECKING then indent y block
    for y in trans:
      dates = []
      quantity = []
      item_trans = y['item_transactions']
      
      if(y['item_id']==2808):
        for z in item_trans:
          dates.insert(len(dates),z['date'])
          quantity.insert(len(quantity),z['quantity'])
        ans = algo(dates,quantity,dates[-1])
        item_name = itemlist.find({"itemid":1},{'itemname':1, "itemid":1, "cat_id":1, "_id":0})
        name={
            'itemid':'',
            'itemname':'',
            'cat_id':'',
            "quantity":ans
        }
        for i in item_name:
            name['itemid']=i['itemid']
            name['itemname']=i['itemname']
            name['cat_id']=i['cat_id']
            output.append(name)
    # RTA CONDITION CHECKING
    
      # for y in trans:
      # dates = []
      # quantity = []
      # item_trans = y['item_transactions']
      
      # if(y['item_id']==2808):
      #   for z in item_trans:
      #     dates.insert(len(dates),z['date'])
      #     quantity.insert(len(quantity),z['quantity'])
      #   ans = algo(dates,quantity,dates[-1])

        
      # item_name = itemlist.find({"itemid":1},{'itemname':1, "itemid":1, "cat_id":1, "_id":0})
      # for i in item_name:
      #     output.append(i)
    # for y in trans:
    #   dates = []
    #   quantity = []
    #   item_trans = y['item_transactions']
    #   ans=0
    #   if(y['item_id']==2808):
    #     for z in item_trans:
    #       dates.insert(len(dates),z['date'])
    #       quantity.insert(len(quantity),z['quantity'])
    #     ans = algo(dates,quantity,dates[-1])
    #     # print("ans:-",ans)

        
      # item_name = itemlist.find({"itemid":1},{'itemname':1, "itemid":1, "cat_id":1, "_id":0})
      #     # print("item name:-",x)
      #     # name={}
      # for i in item_name:
      #     # i["quantity"]=ans
      #     output.append(i)
  return output

(transaction , itemlist , rta) = get_db()


(predicted) = JsonPrediction(transaction,itemlist ,rta)
json_output = json.dumps(predicted)
# print(predicted)
print(json_output)

!pip install pymongo[srv] --user

def algo(dates,quantity,last_date):
  dates = np.array(dates).astype('datetime64[D]')
 
  #preparing frequncy array(dates_arr)
  (dates_arr , quantity) = get_dates_quantity(dates,quantity) 

  #INITIALISING THE MODEL
  svr_poly=SVR(kernel='poly',C=1e3,degree=2,gamma="auto")
  svr_rbf=SVR(kernel='rbf',C=1e3,gamma=0.1)

  #FITTING THE MODEL
  svr_poly.fit(dates_arr,quantity)
  svr_rbf.fit(dates_arr,quantity)

  #READING THE CURRENT TIMESTAMP TO FIND THE GAP
  datetimeobj = datetime.datetime.now()
  date = datetimeobj.strftime("%Y") + "-" +datetimeobj.strftime("%m") + "-" + datetimeobj.strftime("%d")
  
  predict_dates = (datetime.datetime.strptime(date,"%Y-%m-%d")- datetime.datetime.strptime(str(dates[-1]) , "%Y-%m-%d")).days
  predict_dates = np.reshape(predict_dates,(1,1))
 
  #PREDICTING FROM THE FITTED MODEL
  if predict_dates > max(dates_arr):
        maximum = max(dates_arr)[0]
        k = 0
        max_quant = 0
        for i in dates_arr:
            if(i[0] == maximum ):
                if(quantity[k] > max_quant):
                    max_quant = quantity[k]
            k+=1
        return round(max_quant)
        
  elif predict_dates in dates_arr:
        y = svr_poly.predict(predict_dates.reshape(-1,1))[0]
        return round(y)
  else:
        y = svr_rbf.predict(predict_dates.reshape(-1,1))[0]
        return round(y)

def JsonPrediction(transaction , itemlist):
  transaction_inst=
  item = transaction.find({"cust_id":25},{"Transaction.item_transactions.date":1, "Transaction.item_transactions.quantity":1,"Transaction.item_id":1,"_id":0}).sort("Transaction.item_transactions.date")
  
  output = []
  for x in item:
    trans=x["Transaction"]

    for y in trans:
      dates = []
      quantity = []
      item_trans = y['item_transactions']
      ans=0
      if(y['item_id']==2808):
        for z in item_trans:
          dates.insert(len(dates),z['date'])
          quantity.insert(len(quantity),z['quantity'])
        ans = algo(dates,quantity,dates[-1])
        # print("ans:-",ans)

        
      item_name = itemlist.find({"itemid":1},{'itemname':1, "itemid":1, "cat_id":1, "_id":0})
          # print("item name:-",x)
          # name={}
      for i in item_name:
          i["quantity"]=ans
          output.append(i)
  return output

(transaction , itemlist) = get_db()


(predicted) = JsonPrediction(transaction,itemlist)
json_output = json.dumps(predicted)
# print(predicted)
print(json_output)

